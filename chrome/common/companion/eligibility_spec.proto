// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD - style license that can be
// found in the LICENSE file.

// This proto is used to configure the Eligibility Module. It should be kept
// up-to-date with the server-side equivalent proto.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;

package companion.visual_search;

message FeatureLibrary {
  enum ImageLevelFeatureName {
    IMAGE_LEVEL_UNSPECIFIED = 0;

    // Features of the original image.
    IMAGE_ORIGINAL_AREA = 1;
    IMAGE_ORIGINAL_ASPECT_RATIO = 2;
    IMAGE_ORIGINAL_HEIGHT = 11;
    IMAGE_ORIGINAL_WIDTH = 12;

    // Features of the image as scaled on the page. Not all of the area may
    // be visible.
    IMAGE_ONPAGE_AREA = 3;
    IMAGE_ONPAGE_HEIGHT = 9;
    IMAGE_ONPAGE_WIDTH = 10;
    IMAGE_ONPAGE_ASPECT_RATIO = 4;

    // The actually visible area of the image on the page.
    IMAGE_VISIBLE_AREA = 5;

    // Fraction of image that is in viewport. Computed as
    // IMAGE_VISIBLE_AREA / IMAGE_ONPAGE_AREA.
    IMAGE_FRACTION_VISIBLE = 6;

    // Scores of the shopping and sens classifiers.
    SHOPPING_CLASSIFIER_SCORE = 7;
    SENS_CLASSIFIER_SCORE = 8;
  }

  // Enum listing the values of page-level features (used for normalization).
  enum PageLevelFeatureName {
    PAGE_LEVEL_UNSPECIFIED = 0;
    VIEWPORT_AREA = 1;
    // Computed as the max value of the corresponding feature among all the
    // images that are passed in during the first pass of eligibility
    // computation, and then recomputed before the third pass with the images
    // that remain after the second pass.
    MAX_IMAGE_ORIGINAL_AREA = 2;
    MAX_IMAGE_ORIGINAL_ASPECT_RATIO = 3;
    MAX_IMAGE_ONPAGE_AREA = 4;
    MAX_IMAGE_ONPAGE_ASPECT_RATIO = 5;
    MAX_IMAGE_VISIBLE_AREA = 6;
    MAX_IMAGE_FRACTION_VISIBLE = 7;
  }

  // Enum listing the types of thresholding operators.
  enum ThresholdingOp {
    THRESHOLDING_UNSPECIFIED = 0;
    // Greater than.
    GT = 1;
    // Less than.
    LT = 2;
  }
}

// A rule that applies a threshold on a feature. The rule is satisfied if the
// value of the feature with /feature_type/ passes the /threshold/ according to
// the given /op/. Eg. suppose feature_type = IMAGE_ORIGINAL_AREA, op = GT, and
// threshold = 5. Then the rule is satisfied if the original area of the image
// is greater than 5.
message ThresholdingRule {
  optional FeatureLibrary.ImageLevelFeatureName feature_name = 1;
  optional FeatureLibrary.PageLevelFeatureName normalizing_feature_name = 2;
  optional FeatureLibrary.ThresholdingOp op = 3;
  optional float threshold = 4;
}

// An OR-of-thresholding-rules is satisfied if any of the thresholding rules it
// contains are satisfied.
message OrOfThresholdingRules {
  repeated ThresholdingRule rules = 1;
}

// Overall spec for the whole module.
message EligibilitySpec {
  // List of light-weight thresholding rules that we use in the first-cut run to
  // cheaply prune ineligible images. All of the eligibility rules must be
  // satisfied for an image to be considered eligible.
  repeated OrOfThresholdingRules cheap_pruning_rules = 1;
  // These are thresholding rules that depend on more expensive-to-compute
  // inputs such as the sensitivity and intent classifications.
  repeated OrOfThresholdingRules classifier_score_rules = 2;
  // Before running these rules, normalizing features are recomputed only over
  // the images that remain after the second pass.
  repeated OrOfThresholdingRules post_renormalization_rules = 3;
}
